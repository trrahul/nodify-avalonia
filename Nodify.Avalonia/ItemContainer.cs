using System;
using System.Collections.Generic;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Metadata;
using Avalonia.Controls.Presenters;
using Avalonia.Controls.Primitives;
using Avalonia.Data;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.Media;
using Nodify.Avalonia.Connections;
using Nodify.Avalonia.EditorStates;
using Nodify.Avalonia.Events;
using Nodify.Avalonia.Extensions;
using Nodify.Avalonia.Helpers;

namespace Nodify.Avalonia
{
    /// <summary>
    /// Delegate used to notify when an <see cref="ItemContainer"/> is previewing a new location.
    /// </summary>
    /// <param name="newLocation">The new location.</param>
    public delegate void PreviewLocationChanged(Point newLocation);

    /// <summary>
    /// The container for all the items generated by the <see cref="ItemsControl.ItemsSource"/> of the <see cref="NodifyEditor"/>.
    /// </summary>
    [PseudoClasses(IsSelectedPseudoClass,IsPreviewingSelectablePseudoClass,PendingConnection.IsOverElementPseudoClass)]
    public class ItemContainer : ContentControl, INodifyCanvasItem
    {
        private const string IsSelectedPseudoClass = ":isselected";
        private const string IsPreviewingSelectablePseudoClass = ":ispreviewingselectable";
        #region Dependency Properties
        public static readonly StyledProperty<IBrush> HighlightBrushProperty = AvaloniaProperty.Register<ItemContainer,IBrush>(nameof(HighlightBrush));
        public static readonly StyledProperty<IBrush> SelectedBrushProperty = AvaloniaProperty.Register<ItemContainer,IBrush>(nameof(SelectedBrush));
        public static readonly StyledProperty<bool> IsSelectableProperty = AvaloniaProperty.Register<ItemContainer,bool>(nameof(IsSelectable),true);
        public static readonly StyledProperty<bool> IsSelectedProperty =
            SelectingItemsControl.IsSelectedProperty.AddOwner<ItemContainer>();
        public static readonly DirectProperty<ItemContainer, bool?> IsPreviewingSelectionProperty =
            AvaloniaProperty.RegisterDirect<ItemContainer, bool?>(nameof(IsPreviewingSelection),o => o.IsPreviewingSelection);
        public static readonly StyledProperty<Point> LocationProperty = AvaloniaProperty.Register<ItemContainer,Point>(nameof(Location),defaultBindingMode:BindingMode.TwoWay);
        public static readonly StyledProperty<Size> ActualSizeProperty = AvaloniaProperty.Register<ItemContainer,Size>(nameof(ActualSize));
        public static readonly DirectProperty<ItemContainer,Size?> DesiredSizeForSelectionProperty = AvaloniaProperty.RegisterDirect<ItemContainer,Size?>(nameof(DesiredSizeForSelection),o => o.DesiredSizeForSelection);
        public static readonly DirectProperty<ItemContainer,bool> IsPreviewingLocationProperty = AvaloniaProperty.RegisterDirect<ItemContainer, bool>(nameof(IsPreviewingLocation),o => o.IsPreviewingLocation);
        public static readonly StyledProperty<bool> IsDraggableProperty = AvaloniaProperty.Register<ItemContainer,bool>(nameof(IsDraggable), true);

        /// <summary>
        /// Gets or sets the brush used when the <see cref="PendingConnection.IsOverElementProperty"/> attached property is true for this <see cref="ItemContainer"/>.
        /// </summary>
        public IBrush HighlightBrush
        {
            get => GetValue(HighlightBrushProperty);
            set => SetValue(HighlightBrushProperty, value);
        }

        /// <summary>
        /// Gets or sets the brush used when <see cref="IsSelected"/> or <see cref="IsPreviewingSelection"/> is true.
        /// </summary>
        public IBrush SelectedBrush
        {
            get => GetValue(SelectedBrushProperty);
            set => SetValue(SelectedBrushProperty, value);
        }

        /// <summary>
        /// Gets or sets the location of this <see cref="ItemContainer"/> inside the <see cref="NodifyEditor"/> in graph space coordinates.
        /// </summary>
        public Point Location
        {
            get => (Point)GetValue(LocationProperty);
            set => SetValue(LocationProperty, value);
        }

        /// <summary>
        /// Gets or sets a value that indicates whether this <see cref="ItemContainer"/> is selected.
        /// Can only be set if <see cref="IsSelectable"/> is true.
        /// </summary>
        public bool IsSelected
        {
            get => (bool)GetValue(IsSelectedProperty);
            set => SetValue(IsSelectedProperty, value);
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="ItemContainer"/> is about to change its <see cref="IsSelected"/> state.
        /// </summary>
        public bool? IsPreviewingSelection
        {
            get => _isPreviewingSelection;
            internal set
            {
                if (SetAndRaise(IsPreviewingSelectionProperty, ref _isPreviewingSelection, value))
                {
                    PseudoClasses.Set(IsPreviewingSelectablePseudoClass, value == null);
                }
            }
        }

        /// <summary>
        /// Gets or sets whether this <see cref="ItemContainer"/> can be selected.
        /// </summary>
        public bool IsSelectable
        {
            get => (bool)GetValue(IsSelectableProperty);
            set => SetValue(IsSelectableProperty, value);
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="ItemContainer"/> is previewing a new location but didn't logically move there.
        /// </summary>
        public bool IsPreviewingLocation
        {
            get => _isPreviewingLocation;
            protected internal set => SetAndRaise(IsPreviewingLocationProperty,ref _isPreviewingLocation, value);
        }

        /// <summary>
        /// Gets the actual size of this <see cref="ItemContainer"/>.
        /// </summary>
        public Size ActualSize
        {
            get => (Size)GetValue(ActualSizeProperty);
            set => SetValue(ActualSizeProperty, value);
        }

        /// <summary>
        /// Overrides the size to check against when calculating if this <see cref="ItemContainer"/> can be part of the current <see cref="NodifyEditor.SelectedArea"/>.
        /// Defaults to <see cref="UIElement.RenderSize"/>.
        /// </summary>
        public Size? DesiredSizeForSelection
        {
            get => _desiredSizeForSelection;
            set => SetAndRaise(DesiredSizeForSelectionProperty,ref _desiredSizeForSelection, value);
        }

        /// <summary>
        /// Gets or sets whether this <see cref="ItemContainer"/> can be dragged.
        /// </summary>
        public bool IsDraggable
        {
            get => (bool)GetValue(IsDraggableProperty);
            set => SetValue(IsDraggableProperty, value);
        }

        private static void OnLocationChanged(ItemContainer itemContainer, AvaloniaPropertyChangedEventArgs<Point> args)
        {
            itemContainer.OnLocationChanged();
            if (!itemContainer.Editor.IsBulkUpdatingItems)
            {
                itemContainer.Editor.ItemsHost.InvalidateArrange();
            }
        }

        #endregion

        #region Routed Events

        
        public static readonly RoutedEvent DragStartedEvent = RoutedEvent.Register<ItemContainer,VectorEventArgs>(nameof(DragStarted),RoutingStrategies.Bubble);
        public static readonly RoutedEvent DragCompletedEvent = RoutedEvent.Register<ItemContainer,DragCompletedEventArgs>(nameof(DragCompleted),RoutingStrategies.Bubble);
        public static readonly RoutedEvent DragDeltaEvent = RoutedEvent.Register<ItemContainer,VectorEventArgs>(nameof(DragDelta),RoutingStrategies.Bubble);
        //public static readonly RoutedEvent SelectedEvent = RoutedEvent.Register<ItemContainer,SelectionChangedEventArgs>(nameof(Selected),RoutingStrategies.Bubble);
        //public static readonly RoutedEvent UnselectedEvent = RoutedEvent.Register<ItemContainer,SelectionChangedEventArgs>(nameof(Unselected),RoutingStrategies.Bubble);
        public static readonly RoutedEvent IsSelectedChangedEvent = SelectingItemsControl.IsSelectedChangedEvent;
        public static readonly RoutedEvent LocationChangedEvent = RoutedEvent.Register<ItemContainer,RoutedEventArgs>(nameof(LocationChanged),RoutingStrategies.Bubble);

        /// <summary>
        /// Occurs when the <see cref="Location"/> of this <see cref="ItemContainer"/> is changed.
        /// </summary>
        public event EventHandler<RoutedEventArgs> LocationChanged
        {
            add => AddHandler(LocationChangedEvent, value);
            remove => RemoveHandler(LocationChangedEvent, value);
        }

        /// <summary>
        /// Occurs when this <see cref="ItemContainer"/> is the instigator of a drag operation.
        /// </summary>
        public event EventHandler<VectorEventArgs> DragStarted
        {
            add => AddHandler(DragStartedEvent, value);
            remove => RemoveHandler(DragStartedEvent, value);
        }

        /// <summary>
        /// Occurs when this <see cref="ItemContainer"/> is being dragged.
        /// </summary>
        public event EventHandler<VectorEventArgs> DragDelta
        {
            add => AddHandler(DragDeltaEvent, value);
            remove => RemoveHandler(DragDeltaEvent, value);
        }

        /// <summary>
        /// Occurs when this <see cref="ItemContainer"/> completed the drag operation.
        /// </summary>
        public event EventHandler<DragCompletedEventArgs> DragCompleted
        {
            add => AddHandler(DragCompletedEvent, value);
            remove => RemoveHandler(DragCompletedEvent, value);
        }

        /// <summary>
        /// Occurs when this <see cref="ItemContainer"/> is selected.
        /// </summary>
        //public event EventHandler<RoutedEventArgs> Selected
        //{
        //    add => AddHandler(SelectedEvent, value);
        //    remove => RemoveHandler(SelectedEvent, value);
        //}

        /// <summary>
        /// Occurs when this <see cref="ItemContainer"/> is unselected.
        /// </summary>
        //public event EventHandler<RoutedEventArgs> Unselected
        //{
        //    add => AddHandler(UnselectedEvent, value);
        //    remove => RemoveHandler(UnselectedEvent, value);
        //}

        /// <summary>
        /// Raises the <see cref="LocationChangedEvent"/> and sets <see cref="IsPreviewingLocation"/> to false.
        /// </summary>
        protected void OnLocationChanged()
        {
            IsPreviewingLocation = false;
            RaiseEvent(new RoutedEventArgs(LocationChangedEvent, this));
        }

        /// <summary>
        /// Raises the <see cref="SelectedEvent"/> or <see cref="UnselectedEvent"/> based on <paramref name="newValue"/>.
        /// Called when the <see cref="IsSelected"/> value is changed.
        /// </summary>
        /// <param name="newValue">True if selected, false otherwise.</param>
        protected void OnSelectedChanged(bool isSelected)
        {
            // Don't raise the event if the editor is selecting
            if (!Editor.IsSelecting)
            {
                RaiseEvent(new RoutedEventArgs(IsSelectedChangedEvent ,this ));
            }
        }

        private static void OnIsSelectedChanged(ItemContainer itemContainer, AvaloniaPropertyChangedEventArgs<bool> args)
        {
            bool result = itemContainer.IsSelectable && args.NewValue.Value;
            itemContainer.IsSelected = result;
            itemContainer.OnSelectedChanged(result);
            itemContainer.PseudoClasses.Set(IsSelectedPseudoClass, args.NewValue.Value);
        }

        #endregion

        #region Fields

        /// <summary>
        /// Gets or sets whether cancelling a dragging operation is allowed.
        /// </summary>
        public static bool AllowDraggingCancellation { get; set; } = true;

        /// <summary>
        /// The <see cref="NodifyEditor"/> that owns this <see cref="ItemContainer"/>.
        /// </summary>
        public NodifyEditor Editor { get; }

        #endregion

        /// <summary>
        /// Occurs when the <see cref="ItemContainer"/> is previewing a new location.
        /// </summary>
        public event PreviewLocationChanged? PreviewLocationChanged;

        /// <summary>
        /// Raises the <see cref="PreviewLocationChanged"/> event and sets the <see cref="IsPreviewingLocation"/> property to true.
        /// </summary>
        /// <param name="newLocation">The new location.</param>
        protected internal void OnPreviewLocationChanged(Point newLocation)
        {
            IsPreviewingLocation = true;
            PreviewLocationChanged?.Invoke(newLocation);
        }

        static ItemContainer()
        {
            //DefaultStyleKeyProperty.OverrideMetadata(typeof(ItemContainer), new FrameworkPropertyMetadata(typeof(ItemContainer)));
            FocusableProperty.OverrideMetadata(typeof(ItemContainer), new StyledPropertyMetadata<bool>(true));
            IsSelectedProperty.Changed.AddClassHandler<ItemContainer, bool>(OnIsSelectedChanged);
            LocationProperty.Changed.AddClassHandler<ItemContainer, Point>(OnLocationChanged);
            PendingConnection.IsOverElementProperty.Changed.AddClassHandler<ItemContainer, bool>((o, e) =>
                o.PseudoClasses.Set(PendingConnection.IsOverElementPseudoClass, e.NewValue.Value));
        }

        /// <summary>
        /// Constructs an instance of an <see cref="ItemContainer"/> in the specified <see cref="NodifyEditor"/>.
        /// </summary>
        /// <param name="editor"></param>
        public ItemContainer(NodifyEditor editor)
        {
            Editor = editor;
            _states.Push(GetInitialState());
            SizeChanged += OnRenderSizeChanged;
        }

        protected override void OnApplyTemplate(TemplateAppliedEventArgs e)
        {
            base.OnApplyTemplate(e);
            State.Enter(null);
        }

        /// <inheritdoc />
        private void OnRenderSizeChanged(object? sender, SizeChangedEventArgs args)
        {
            ActualSize = args.NewSize;
        }

        protected override bool RegisterContentPresenter(ContentPresenter presenter)
        {
            return base.RegisterContentPresenter(presenter);
        }

        /// <summary>
        /// Checks if <paramref name="position"/> is selectable.
        /// </summary>
        /// <param name="position">A position relative to this <see cref="ItemContainer"/>.</param>
        /// <returns>True if <paramref name="position"/> is selectable.</returns>
        protected virtual bool IsSelectableLocation(Point position)
        {
            Size size = DesiredSizeForSelection ?? Bounds.Size;
            return position.X >= 0 && position.Y >= 0 && position.X <= size.Width && position.Y <= size.Height;
        }

        /// <summary>
        /// Checks if <paramref name="area"/> contains or intersects with this <see cref="ItemContainer"/> taking into consideration the <see cref="DesiredSizeForSelection"/>.
        /// </summary>
        /// <param name="area">The area to check if contains or intersects this <see cref="ItemContainer"/>.</param>
        /// <param name="isContained">If true will check if <paramref name="area"/> contains this, otherwise will check if <paramref name="area"/> intersects with this.</param>
        /// <returns>True if <paramref name="area"/> contains or intersects this <see cref="ItemContainer"/>.</returns>
        public virtual bool IsSelectableInArea(Rect area, bool isContained)
        {
            var bounds = new Rect(Location, DesiredSizeForSelection ?? Bounds.Size * Editor.ViewportZoom);
            return isContained ? area.Contains(bounds) : area.IntersectsWith(bounds);
        }

        #region State Handling

        private readonly Stack<ContainerState> _states = new Stack<ContainerState>();
        private bool? _isPreviewingSelection;
        private bool _isPreviewingLocation;
        private Size? _desiredSizeForSelection;

        /// <summary>The current state of the container.</summary>
        public ContainerState State => _states.Peek();

        /// <summary>Creates the initial state of the container.</summary>
        /// <returns>The initial state.</returns>
        protected virtual ContainerState GetInitialState()
            => new ContainerDefaultState(this);

        /// <summary>Pushes the given state to the stack.</summary>
        /// <param name="state">The new state of the container.</param>
        /// <remarks>Calls <see cref="ContainerState.Enter"/> on the new state.</remarks>
        public void PushState(ContainerState state)
        {
            var prev = State;
            _states.Push(state);
            state.Enter(prev);
        }

        /// <summary>Pops the current <see cref="State"/> from the stack.</summary>
        /// <remarks>It doesn't pop the initial state. (see <see cref="GetInitialState"/>)
        /// <br />Calls <see cref="ContainerState.Exit"/> on the current state.
        /// <br />Calls <see cref="ContainerState.ReEnter"/> on the previous state.
        /// </remarks>
        public void PopState()
        {
            // Never remove the default state
            if (_states.Count > 1)
            {
                ContainerState prev = _states.Pop();
                prev.Exit();
                State.ReEnter(prev);
            }
        }

        /// <summary>Pops all states from the container.</summary>
        /// <remarks>It doesn't pop the initial state. (see <see cref="GetInitialState"/>)</remarks>
        public void PopAllStates()
        {
            while (_states.Count > 1)
            {
                PopState();
            }
        }

        /// <inheritdoc />

        protected override void OnPointerPressed(PointerPressedEventArgs e)
        {
            if (IsSelectableLocation(e.GetPosition(this)))
            {
                Focus();
                this.CaptureMouseSafe(e);
                State.HandlePointerPressed(e);
            }
        }

        /// <inheritdoc />
        protected override void OnPointerReleased(PointerReleasedEventArgs e)
        {
            var isMouseCaptured = this.IsMouseCaptured(e);
            if (IsSelectableLocation(e.GetPosition(this)) || isMouseCaptured)
            {
                State.HandlePointerReleased(e);
            }

            var props = e.GetPointerPointProperties();
            if (isMouseCaptured && !props.IsRightButtonPressed && !props.IsLeftButtonPressed && !props.IsMiddleButtonPressed)
            {
                this.ReleaseMouseCapture(e);
            }
        }

        /// <inheritdoc />

        protected override void OnPointerMoved(PointerEventArgs e)
        {
            State.HandlePointerMove(e);
        }

        /// <inheritdoc />

        protected override void OnPointerWheelChanged(PointerWheelEventArgs e)
        {
            State.HandlePointerWheel(e);
        }

        /// <inheritdoc />

        protected override void OnPointerCaptureLost(PointerCaptureLostEventArgs e) => PopAllStates();

        protected override void OnKeyUp(KeyEventArgs e)
            => State.HandleKeyUp(e);

        protected override void OnKeyDown(KeyEventArgs e)
            => State.HandleKeyDown(e);

        #endregion
    }
}
